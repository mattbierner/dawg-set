{"version":3,"sources":["dawg.js"],"names":[],"mappings":"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","file":"dawg.js","sourcesContent":["/**\n * Directed Acyclic Word Graph (DAWG)\n * \n * Based on https://gist.github.com/smhanov/94230b422c2100ae4218\n */\n\"use strict\";\n\nconst slice = Array.prototype.slice;\n\nconst join = (joiner) =>\n    typeof joiner === 'function'\n        ? joiner\n        : (acc, current) => (acc === null ? '' : acc + joiner) + current;\n\nconst createEmptyNode = id => ({\n    edges: new Map(),\n    final: false,\n    id: id\n});\n\n/* Traversal\n ******************************************************************************/\nconst DONE = { done: true };\n\nconst Iterator = function (root, initial, join) {\n    // Linked list stack of nodes to visit.\n    this.stack = root && { node: root, value: initial, rest: null };\n    this.join = join;\n};\n\nIterator.prototype.next = function () {\n    while (this.stack) {\n        const head = this.stack;\n        // Replace head of stack with visits to child edges of head node, then\n        // remove head.\n        let r = head;\n        for (let [edge, value] of head.node.edges)\n            r = r.rest = ({ node: value, value: this.join(head.value, edge), rest: r.rest });\n        this.stack = this.stack.rest;\n\n        if (head.node.final)\n            return head;\n    }\n    return DONE;\n};\n\nIterator.prototype[Symbol.iterator] = function () {\n    return this;\n};\n\n/* Dawg\n ******************************************************************************/\nconst lexicographicalCompare = (a, b) =>\n    a.localeCompare(b);\n\nconst encode = node => {\n    let s = +node.final;\n    for (let [k, v] of node.edges)\n        s += `_${k}_${v.id}`;\n    return s;\n};\n\nconst DEFAULT_OPTIONS = {\n    compare(a, b) {\n        if (typeof a === 'string')\n            return lexicographicalCompare(a, b);\n\n        const lenA = a.length;\n        const lenB = b.length;\n        for (let i = 0; i < lenA && i < lenB; ++i) {\n            const r = lexicographicalCompare(a[i], b[i]);\n            if (r !== 0)\n                return r;\n        }\n        return lenA - lenB;\n    }\n};\n\n/**\n * \n */\nexport default class Dawg {\n    /**\n     * @param paths Optional iterable of paths to insert into the new DAWG.\n     */\n    constructor(paths, options) {\n        this._options = Object.assign({}, options, DEFAULT_OPTIONS);\n\n        this._count = 0;\n        this._id = 0;\n        this._root = createEmptyNode(this._id++);\n\n        this._previous = \"\";\n        this._uncheckedNodes = []\n        this._minimizedNodes = {};\n\n        if (paths)\n            for (let p of paths)\n                this.add(p);\n    }\n\n    /**\n      * Get the number of entries in the DAWG.\n      */\n    count() {\n        return this._count;\n    }\n\n    /**\n     * Add an entry to the DAWG.\n     * \n     * Entries must be added in lexographic order and cannot be added after\n     * the DAWG is marked as finalized.\n     * \n     * @param path Path components to add.\n     */\n    add(path) {\n        if (this._finalized)\n            throw new Error(\"Dawg finalized, cannot insert new entries\");\n\n        const order = this._options.compare(path, this._previous);\n        if (order < 0)\n            throw new Error(\"Paths must be inserted in lexograpic order\");\n        if (order === 0)\n            return this;\n\n        let commonPrefix = 0;\n        for (; commonPrefix < path.length && commonPrefix < this._previous.length; ++commonPrefix)\n            if (path[commonPrefix] !== this._previous[commonPrefix])\n                break\n\n        this._minimize(commonPrefix)\n\n        let node = this._uncheckedNodes.length === 0 ? this._root : this._uncheckedNodes[this._uncheckedNodes.length - 1][2];\n\n        for (let letter of slice.call(path, commonPrefix)) {\n            let nextNode = createEmptyNode(this._id++);\n            node.edges.set(letter, nextNode);\n            this._uncheckedNodes.push([node, letter, nextNode]);\n            node = nextNode;\n        }\n\n        node.final = true;\n        this._previous = path;\n        ++this._count;\n        return this;\n    }\n\n    _findNode(path) {\n        let node = this._root;\n        let i = 0;\n        for (let x of path) {\n            if (!node)\n                return [null, 0];\n            node = node.edges.get(x);\n            ++i;\n        }\n        return [node, i];\n    }\n\n    /**\n     * Find the length of the longest match for `path` in the dawg.\n     *\n     * @returns a number in `[0, path.length]` indicating the longest match.\n     * \n     * @see match For actually getting the longest match\n     */\n    longest(path) {\n        let best = 0;\n        let node = this._root;\n        if (node) {\n            let i = 0;\n            for (let x of path) {\n                node = node.edges.get(x);\n                if (!node)\n                    break;\n                ++i;\n                if (node.final)\n                    best = i;\n            }\n        }\n        return best;\n    }\n\n    /**\n     * Does an exact entry for `path` exists in the DAWG?\n     */\n    has(path) {\n        return this.longest(path) === path.length;\n    }\n\n    /**\n     * Return the path for the longest match in the dawg.\n     * \n     * @see longest\n     */\n    match(path, joiner = '') {\n        return slice.call(path, 0, this.longest(path)).join('');\n    }\n\n    /**\n     * Mark the current DAWG as complete.\n     * \n     * Prevents further modifications.\n     */\n    finalize() {\n        if (!this._finalized) {\n            this._minimize(0);\n            this._minimizedNodes = null;\n            this._uncheckedNodes = null;\n            this._finalized = true;\n        }\n        return this;\n    }\n\n    /**\n     * Get an iterator to all paths in the dawg.\n     * \n     * Yields arrays of raw path elements, not the joined strings.\n     */\n    paths() {\n        return new Iterator(this._root, [], (acc, current) => acc.concat(current));\n    }\n\n    /**\n     * Get an iterator to all values in the dawg.\n     * \n     * @param joiner String or function used to join paths together into strings.\n     */\n    values(joiner = '') {\n        return new Iterator(this._root, null, join(joiner));\n    }\n\n    /**\n     * Get an iterator to all values starting with `path` in the dawg.\n     * \n     * @see values\n     */\n    valuesStartingWith(path, joiner = '') {\n        const [root, index] = this._findNode(path);\n        const joinFn = join(joiner);\n        return new Iterator(root, slice.call(path, 0, index).reduce(joinFn, null), joinFn);\n    }\n\n    _minimize(downTo) {\n        for (let i = 0, len = this._uncheckedNodes.length - downTo; i < len; ++i) {\n            const [parent, letter, child] = this._uncheckedNodes.pop();\n            const key = encode(child);\n            const existing = this._minimizedNodes[key];\n            if (existing) {\n                parent.edges.set(letter, existing);\n            } else {\n                this._minimizedNodes[key] = child;\n            }\n        }\n    }\n}\n\nDawg.prototype[Symbol.iterator] = Dawg.prototype.values;\n\n/**\n * Create a finalized DAWG from an iterable.\n * \n * @see new Dawg()\n */\nexport const from = Dawg.from = (paths, options) =>\n    new Dawg(paths, options).finalize();\n"],"sourceRoot":"/source/"}