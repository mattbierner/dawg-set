{"version":3,"sources":["dawg.js"],"names":[],"mappings":";;;AAGA;;;;;;;;;;;;AAEA,IAAM,QAAQ,MAAM,SAAN,CAAgB,KAA9B;;AAEA,IAAM,kBAAkB,SAAlB,eAAkB;AAAA,WAAO;AAC3B,eAAO,EADoB;AAE3B,eAAO,KAFoB;AAG3B,YAAI;AAHuB,KAAP;AAAA,CAAxB;;AAMA,IAAM,yBAAyB,SAAzB,sBAAyB,CAAC,CAAD,EAAI,CAAJ;AAAA,WAC3B,EAAE,aAAF,CAAgB,CAAhB,CAD2B;AAAA,CAA/B;;AAGA,IAAM,SAAS,SAAT,MAAS,OAAQ;AACnB,QAAI,IAAI,CAAC,KAAK,KAAd;AADmB;AAAA;AAAA;;AAAA;AAEnB,6BAAc,OAAO,IAAP,CAAY,KAAK,KAAjB,CAAd;AAAA,gBAAS,CAAT;;AACI,uBAAS,CAAT,SAAc,KAAK,KAAL,CAAW,CAAX,EAAc,EAA5B;AADJ;AAFmB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAInB,WAAO,CAAP;AACH,CALD;;AAOA,IAAM,kBAAkB;AACpB,WADoB,mBACZ,CADY,EACT,CADS,EACN;AACV,YAAI,OAAO,CAAP,KAAa,QAAjB,EACI,OAAO,uBAAuB,CAAvB,EAA0B,CAA1B,CAAP;;AAEJ,YAAM,OAAO,EAAE,MAAf;AACA,YAAM,OAAO,EAAE,MAAf;AACA,aAAK,IAAI,IAAI,CAAb,EAAgB,IAAI,IAAJ,IAAY,IAAI,IAAhC,EAAsC,EAAE,CAAxC,EAA2C;AACvC,gBAAM,IAAI,uBAAuB,EAAE,CAAF,CAAvB,EAA6B,EAAE,CAAF,CAA7B,CAAV;AACA,gBAAI,MAAM,CAAV,EACI,OAAO,CAAP;AACP;AACD,eAAO,OAAO,IAAd;AACH;AAbmB,CAAxB;;;;;;IAmBqB,I;;;;;AAIjB,kBAAY,KAAZ,EAAmB,OAAnB,EAA4B;AAAA;;AACxB,aAAK,QAAL,GAAgB,OAAO,MAAP,CAAc,EAAd,EAAkB,OAAlB,EAA2B,eAA3B,CAAhB;;AAEA,aAAK,MAAL,GAAc,CAAd;AACA,aAAK,GAAL,GAAW,CAAX;AACA,aAAK,KAAL,GAAa,gBAAgB,KAAK,GAAL,EAAhB,CAAb;;AAEA,aAAK,SAAL,GAAiB,EAAjB;AACA,aAAK,eAAL,GAAuB,EAAvB;AACA,aAAK,eAAL,GAAuB,IAAI,GAAJ,EAAvB;;AAEA,YAAI,KAAJ;AAAA;AAAA;AAAA;;AAAA;AACI,sCAAc,KAAd;AAAA,wBAAS,EAAT;;AACI,yBAAK,GAAL,CAAS,EAAT;AADJ;AADJ;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGH;;;;;;;;;;;;;;4BAUG,I,EAAM;AACN,gBAAI,KAAK,UAAT,EACI,MAAM,2CAAN;;AAEJ,gBAAM,QAAQ,KAAK,QAAL,CAAc,OAAd,CAAsB,IAAtB,EAA4B,KAAK,SAAjC,CAAd;AACA,gBAAI,QAAQ,CAAZ,EACI,MAAM,4CAAN;AACJ,gBAAI,UAAU,CAAd,EACI,OAAO,IAAP;;AAEJ,gBAAI,eAAe,CAAnB;AACA,mBAAO,eAAe,KAAK,MAApB,IAA8B,eAAe,KAAK,SAAL,CAAe,MAAnE,EAA2E,EAAE,YAA7E;AACI,oBAAI,KAAK,YAAL,MAAuB,KAAK,SAAL,CAAe,YAAf,CAA3B,EACI;AAFR,aAIA,KAAK,SAAL,CAAe,YAAf;;AAEA,gBAAI,OAAO,KAAK,eAAL,CAAqB,MAArB,KAAgC,CAAhC,GAAoC,KAAK,KAAzC,GAAiD,KAAK,eAAL,CAAqB,KAAK,eAAL,CAAqB,MAArB,GAA8B,CAAnD,EAAsD,CAAtD,CAA5D;;AAjBM;AAAA;AAAA;;AAAA;AAmBN,sCAAmB,MAAM,IAAN,CAAW,IAAX,EAAiB,YAAjB,CAAnB,mIAAmD;AAAA,wBAA1C,MAA0C;;AAC/C,wBAAI,WAAW,gBAAgB,KAAK,GAAL,EAAhB,CAAf;AACA,yBAAK,KAAL,CAAW,MAAX,IAAqB,QAArB;AACA,yBAAK,eAAL,CAAqB,IAArB,CAA0B,CAAC,IAAD,EAAO,MAAP,EAAe,QAAf,CAA1B;AACA,2BAAO,QAAP;AACH;AAxBK;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AA0BN,iBAAK,KAAL,GAAa,IAAb;AACA,iBAAK,SAAL,GAAiB,IAAjB;AACA,cAAE,KAAK,MAAP;AACA,mBAAO,IAAP;AACH;;;;;;;;4BAKG,I,EAAM;AACN,gBAAI,OAAO,KAAK,KAAhB;AADM;AAAA;AAAA;;AAAA;AAEN,sCAAc,IAAd,mIAAoB;AAAA,wBAAX,CAAW;;AAChB,2BAAO,KAAK,KAAL,CAAW,CAAX,CAAP;AACA,wBAAI,CAAC,IAAL,EACI,OAAO,KAAP;AACP;AANK;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAON,mBAAO,KAAK,KAAZ;AACH;;;;;;;;gCAKO;AACJ,mBAAO,KAAK,MAAZ;AACH;;;;;;;;;;mCAOU;AACP,gBAAI,CAAC,KAAK,UAAV,EAAsB;AAClB,qBAAK,SAAL,CAAe,CAAf;AACA,qBAAK,eAAL,GAAuB,IAAvB;AACA,qBAAK,eAAL,GAAuB,IAAvB;AACA,qBAAK,UAAL,GAAkB,IAAlB;AACH;AACD,mBAAO,IAAP;AACH;;;kCAES,M,EAAQ;AACd,iBAAK,IAAI,IAAI,CAAR,EAAW,MAAM,KAAK,eAAL,CAAqB,MAArB,GAA8B,MAApD,EAA4D,IAAI,GAAhE,EAAqE,EAAE,CAAvE,EAA0E;AAAA,0CACtC,KAAK,eAAL,CAAqB,GAArB,EADsC;;AAAA;;AAAA,oBAC/D,MAD+D;AAAA,oBACvD,MADuD;AAAA,oBAC/C,KAD+C;;AAEtE,oBAAM,MAAM,OAAO,KAAP,CAAZ;AACA,oBAAM,WAAW,KAAK,eAAL,CAAqB,GAArB,CAAyB,GAAzB,CAAjB;AACA,oBAAI,QAAJ,EAAc;AACV,2BAAO,KAAP,CAAa,MAAb,IAAuB,QAAvB;AACH,iBAFD,MAEO;AACH,yBAAK,eAAL,CAAqB,GAArB,CAAyB,GAAzB,EAA8B,KAA9B;AACH;AACJ;AACJ;;;;;;;;;;;;;kBA1GgB,I;AAkHd,IAAM,sBAAO,KAAK,IAAL,GAAY,UAAC,KAAD,EAAQ,OAAR;AAAA,WAC5B,IAAI,IAAJ,CAAS,KAAT,EAAgB,OAAhB,EAAyB,QAAzB,EAD4B;AAAA,CAAzB","file":"dawg.js","sourcesContent":["/**\n * \n */\n\"use strict\";\n\nconst slice = Array.prototype.slice;\n\nconst createEmptyNode = id => ({\n    edges: {},\n    final: false,\n    id: id\n});\n\nconst lexicographicalCompare = (a, b) =>\n    a.localeCompare(b);\n\nconst encode = node => {\n    let s = +node.final;\n    for (let k of Object.keys(node.edges))\n        s += `_${k}_${node.edges[k].id}`;\n    return s;\n};\n\nconst DEFAULT_OPTIONS = {\n    compare(a, b) {\n        if (typeof a === 'string')\n            return lexicographicalCompare(a, b);\n\n        const lenA = a.length;\n        const lenB = b.length;\n        for (let i = 0; i < lenA && i < lenB; ++i) {\n            const r = lexicographicalCompare(a[i], b[i]);\n            if (r !== 0)\n                return r;\n        }\n        return lenA - lenB;\n    }\n};\n\n/**\n * \n */\nexport default class Dawg {\n    /**\n     * @param paths Optional iterable of paths to insert into the new DAWG.\n     */\n    constructor(paths, options) {\n        this._options = Object.assign({}, options, DEFAULT_OPTIONS);\n\n        this._count = 0;\n        this._id = 0;\n        this._root = createEmptyNode(this._id++);\n\n        this._previous = \"\";\n        this._uncheckedNodes = []\n        this._minimizedNodes = new Map();\n\n        if (paths)\n            for (let p of paths)\n                this.add(p);\n    }\n\n    /**\n     * Add an entry to the DAWG.\n     * \n     * Entries must be added in lexographic order and cannot be added after\n     * the DAWG is marked as finalized.\n     * \n     * @param path Path components to add.\n     */\n    add(path) {\n        if (this._finalized)\n            throw \"Dawg finalized, cannot insert new entries\";\n\n        const order = this._options.compare(path, this._previous);\n        if (order < 0)\n            throw \"Paths must be inserted in lexograpic order\";\n        if (order === 0)\n            return this;\n\n        let commonPrefix = 0;\n        for (; commonPrefix < path.length && commonPrefix < this._previous.length; ++commonPrefix)\n            if (path[commonPrefix] !== this._previous[commonPrefix])\n                break\n\n        this._minimize(commonPrefix)\n\n        let node = this._uncheckedNodes.length === 0 ? this._root : this._uncheckedNodes[this._uncheckedNodes.length - 1][2];\n\n        for (let letter of slice.call(path, commonPrefix)) {\n            let nextNode = createEmptyNode(this._id++);\n            node.edges[letter] = nextNode;\n            this._uncheckedNodes.push([node, letter, nextNode]);\n            node = nextNode;\n        }\n\n        node.final = true;\n        this._previous = path;\n        ++this._count;\n        return this;\n    }\n\n    /**\n     * Does an entry for `path` exists in the DAWG?\n     */\n    has(path) {\n        let node = this._root;\n        for (let x of path) {\n            node = node.edges[x];\n            if (!node)\n                return false;\n        }\n        return node.final;\n    }\n\n    /**\n     * Get the number of entries in the DAWG.\n     */\n    count() {\n        return this._count;\n    }\n\n    /**\n     * Mark the current DAWG as complete.\n     * \n     * Prevents further modifications.\n     */\n    finalize() {\n        if (!this._finalized) {\n            this._minimize(0);\n            this._minimizedNodes = null;\n            this._uncheckedNodes = null;\n            this._finalized = true;\n        }\n        return this;\n    }\n\n    _minimize(downTo) {\n        for (let i = 0, len = this._uncheckedNodes.length - downTo; i < len; ++i) {\n            const [parent, letter, child] = this._uncheckedNodes.pop();\n            const key = encode(child);\n            const existing = this._minimizedNodes.get(key);\n            if (existing) {\n                parent.edges[letter] = existing;\n            } else {\n                this._minimizedNodes.set(key, child);\n            }\n        }\n    }\n}\n\n/**\n * Create a finalized DAWG from an iterable.\n * \n * @see new Dawg()\n */\nexport const from = Dawg.from = (paths, options) =>\n    new Dawg(paths, options).finalize();\n"],"sourceRoot":"/source/"}